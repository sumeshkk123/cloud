"use client";

import { useMemo, useState } from "react";

import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";
import {
  Activity,
  ArrowRight,
  GaugeCircle,
  LineChart,
  Rocket,
  Users
} from "lucide-react";

type HybridPlanSimulatorProps = {
  className?: string;
};

type TimelineStep = {
  label: string;
  value: string;
  hint: string;
  highlighted?: boolean;
};

type HybridStats = {
  pairRequirement: number;
  activePromoters: number;
  projectedRevenue: number;
  projectedPayout: number;
  payoutMix: {
    binary: number;
    matrix: number;
    unilevel: number;
  };
  binaryPairs: number;
  binaryPayoutValue: number;
  matrixPayoutValue: number;
  unilevelPayoutValue: number;
  matrixFillRate: number;
  matrixCapacity: number;
  matrixAllocated: number;
  overrideCoverage: number;
  leadershipReady: number;
  reentryEligible: number;
  cycleDays: number;
  timeline: TimelineStep[];
};

const HYBRID_PAIR_REQUIREMENTS = [300, 450, 600] as const;
const HYBRID_PROMOTERS = [320, 520, 760] as const;
const HYBRID_BINARY_WEIGHTS = [0.4, 0.5, 0.6] as const;
const HYBRID_MATRIX_WIDTHS = [3, 4, 5] as const;
const HYBRID_OVERRIDE_DEPTHS = [3, 5, 7] as const;

export default function HybridPlanSimulator({ className }: HybridPlanSimulatorProps) {
  const [pairRequirement, setPairRequirement] = useState<number>(HYBRID_PAIR_REQUIREMENTS[1]);
  const [activePromoters, setActivePromoters] = useState<number>(HYBRID_PROMOTERS[1]);
  const [avgOrderValue, setAvgOrderValue] = useState<number>(260);
  const [binaryWeight, setBinaryWeight] = useState<number>(HYBRID_BINARY_WEIGHTS[1]);
  const [matrixWidth, setMatrixWidth] = useState<number>(HYBRID_MATRIX_WIDTHS[1]);
  const [overrideDepth, setOverrideDepth] = useState<number>(HYBRID_OVERRIDE_DEPTHS[1]);

  const formatter = useMemo(
    () =>
      new Intl.NumberFormat("en-US", {
        style: "currency",
        currency: "USD",
        maximumFractionDigits: 0
      }),
    []
  );

  const stats = useMemo<HybridStats>(() => {
    const projectedRevenue = activePromoters * avgOrderValue;

    const rawBinary = Math.max(Math.round(binaryWeight * 100), 1);
    const rawMatrix = matrixWidth * 12;
    const rawUnilevel = overrideDepth * 15;
    const rawTotal = rawBinary + rawMatrix + rawUnilevel;

    const binaryMix = Math.round((rawBinary / rawTotal) * 100);
    const matrixMix = Math.round((rawMatrix / rawTotal) * 100);
    let unilevelMix = 100 - binaryMix - matrixMix;
    if (unilevelMix < 0) {
      unilevelMix = 0;
    }

    const projectedPayout = Math.round(projectedRevenue * 0.32);
    const binaryPayoutValue = Math.round((projectedPayout * binaryMix) / 100);
    const matrixPayoutValue = Math.round((projectedPayout * matrixMix) / 100);
    const unilevelPayoutValue = Math.max(projectedPayout - binaryPayoutValue - matrixPayoutValue, 0);

    const binaryPairs =
      pairRequirement === 0 ? 0 : Math.max(Math.round((activePromoters * binaryWeight) / 2), 0);

    const matrixDepth = 4;
    const matrixCapacity = Math.pow(matrixWidth, matrixDepth);
    const matrixAllocated = Math.min(matrixCapacity, Math.round(activePromoters * 0.55));
    const matrixFillRate = matrixCapacity === 0 ? 0 : Math.round((matrixAllocated / matrixCapacity) * 100);

    const overrideCoverage = Math.min(
      100,
      Math.round((overrideDepth / 7) * 85 + unilevelMix * 0.2)
    );
    const leadershipReady = Math.max(Math.round(activePromoters * 0.06 * (overrideDepth / 5)), 3);
    const reentryEligible = Math.max(Math.round(activePromoters * 0.1 * (1 - binaryWeight + 0.3)), 2);

    const cycleDays = Math.max(18, Math.round(14 + matrixWidth * 2 + overrideDepth));

    const timeline: TimelineStep[] = [
      {
        label: "Projected hybrid revenue",
        value: formatter.format(projectedRevenue),
        hint: "Gross order volume generated by active promoters under the current blend.",
        highlighted: true
      },
      {
        label: "Payout pool",
        value: formatter.format(projectedPayout),
        hint: `${binaryMix}% binary · ${matrixMix}% matrix · ${unilevelMix}% unilevel distribution.`,
        highlighted: true
      },
      {
        label: "Binary matches",
        value: `${binaryPairs} pairs`,
        hint: `${pairRequirement} PV required before bonuses trigger.`
      },
      {
        label: "Matrix occupancy",
        value: `${matrixFillRate}% filled`,
        hint: `${matrixAllocated} seats of ${matrixCapacity} active in the spillover queue.`
      },
      {
        label: "Override coverage",
        value: `${overrideCoverage}% coverage`,
        hint: `${leadershipReady} leaders tracking full-depth override eligibility.`
      }
    ];

    return {
      pairRequirement,
      activePromoters,
      projectedRevenue,
      projectedPayout,
      payoutMix: {
        binary: binaryMix,
        matrix: matrixMix,
        unilevel: unilevelMix
      },
      binaryPairs,
      binaryPayoutValue,
      matrixPayoutValue,
      unilevelPayoutValue,
      matrixFillRate,
      matrixCapacity,
      matrixAllocated,
      overrideCoverage,
      leadershipReady,
      reentryEligible,
      cycleDays,
      timeline
    };
  }, [
    activePromoters,
    avgOrderValue,
    binaryWeight,
    formatter,
    matrixWidth,
    overrideDepth,
    pairRequirement
  ]);

  const sliderDisplayValue = formatter.format(avgOrderValue);

  return (
    <div
      className={cn(
        "flex h-full flex-col gap-6 rounded-3xl border border-border/60 bg-background/90 p-6 shadow-2xl backdrop-blur-lg dark:border-white/10 dark:bg-white/5",
        className
      )}
    >
      <header className="space-y-1">
        <span className="text-xs font-semibold uppercase tracking-wide text-primary">Hybrid plan simulator</span>
        <h3 className="text-xl font-semibold text-foreground dark:text-white">
          Model how binary, matrix, and unilevel incentives combine.
        </h3>
      </header>

      <div className="grid gap-4">
        <div className="grid gap-2">
          <span className="text-xs font-medium uppercase tracking-wide text-muted-foreground">
            Binary pair requirement (PV)
          </span>
          <div className="flex flex-wrap gap-2">
            {HYBRID_PAIR_REQUIREMENTS.map((option) => (
              <Button
                key={option}
                type="button"
                variant={option === pairRequirement ? "default" : "outline"}
                size="sm"
                onClick={() => setPairRequirement(option)}
              >
                {option} PV
              </Button>
            ))}
          </div>
        </div>

        <div className="grid gap-2">
          <span className="text-xs font-medium uppercase tracking-wide text-muted-foreground">
            Active promoters this cycle
          </span>
          <div className="flex flex-wrap gap-2">
            {HYBRID_PROMOTERS.map((option) => (
              <Button
                key={option}
                type="button"
                variant={option === activePromoters ? "default" : "outline"}
                size="sm"
                onClick={() => setActivePromoters(option)}
              >
                {option}
              </Button>
            ))}
          </div>
        </div>

        <div className="grid gap-2">
          <span className="text-xs font-medium uppercase tracking-wide text-muted-foreground">
            Binary payout emphasis
          </span>
          <div className="flex flex-wrap gap-2">
            {HYBRID_BINARY_WEIGHTS.map((option) => (
              <Button
                key={option}
                type="button"
                variant={option === binaryWeight ? "default" : "outline"}
                size="sm"
                onClick={() => setBinaryWeight(option)}
              >
                {Math.round(option * 100)}%
              </Button>
            ))}
          </div>
        </div>

        <div className="grid gap-2">
          <span className="text-xs font-medium uppercase tracking-wide text-muted-foreground">
            Matrix spillover width
          </span>
          <div className="flex flex-wrap gap-2">
            {HYBRID_MATRIX_WIDTHS.map((option) => (
              <Button
                key={option}
                type="button"
                variant={option === matrixWidth ? "default" : "outline"}
                size="sm"
                onClick={() => setMatrixWidth(option)}
              >
                {option}-wide
              </Button>
            ))}
          </div>
        </div>

        <div className="grid gap-2">
          <span className="text-xs font-medium uppercase tracking-wide text-muted-foreground">
            Override depth (levels)
          </span>
          <div className="flex flex-wrap gap-2">
            {HYBRID_OVERRIDE_DEPTHS.map((option) => (
              <Button
                key={option}
                type="button"
                variant={option === overrideDepth ? "default" : "outline"}
                size="sm"
                onClick={() => setOverrideDepth(option)}
              >
                {option} levels
              </Button>
            ))}
          </div>
        </div>

        <div className="grid gap-2">
          <div className="flex items-center justify-between text-xs font-medium uppercase tracking-wide text-muted-foreground">
            <span>Average order value (USD)</span>
            <span className="text-foreground dark:text-white">{sliderDisplayValue}</span>
          </div>
          <input
            type="range"
            min={180}
            max={520}
            step={10}
            value={avgOrderValue}
            onChange={(event) => setAvgOrderValue(Number(event.target.value))}
            className="h-1 w-full cursor-pointer appearance-none rounded-full bg-primary/30 accent-primary"
          />
        </div>
      </div>

      <div className="relative grid gap-4 rounded-2xl border border-border/60 bg-muted/30 p-4 dark:border-white/10 dark:bg-white/5">
        <HybridPayoutDiagram
          payoutMix={stats.payoutMix}
          projectedPayout={stats.projectedPayout}
          binaryPayout={stats.binaryPayoutValue}
          matrixPayout={stats.matrixPayoutValue}
          unilevelPayout={stats.unilevelPayoutValue}
          formatter={formatter}
        />
        <p className="text-xs text-muted-foreground">
          Compare payout mix across binary, matrix, and unilevel streams before publishing plan changes.
        </p>
      </div>

      <dl className="grid gap-3 rounded-2xl border border-border/60 bg-background/80 p-4 dark:border-white/10 dark:bg-white/5">
        <div className="flex items-center justify-between gap-3">
          <div className="flex items-center gap-2 text-sm text-muted-foreground">
            <LineChart className="h-4 w-4 text-primary" aria-hidden />
            Projected payout pool
          </div>
          <span className="text-sm font-semibold text-foreground dark:text-white">
            {formatter.format(stats.projectedPayout)}
          </span>
        </div>
        <div className="flex items-center justify-between gap-3">
          <div className="flex items-center gap-2 text-sm text-muted-foreground">
            <Users className="h-4 w-4 text-primary" aria-hidden />
            Binary payout share
          </div>
          <span className="text-sm font-semibold text-foreground dark:text-white">
            {formatter.format(stats.binaryPayoutValue)}
            <span className="ml-1 text-xs font-medium text-muted-foreground">({stats.payoutMix.binary}%)</span>
          </span>
        </div>
        <div className="flex items-center justify-between gap-3">
          <div className="flex items-center gap-2 text-sm text-muted-foreground">
            <GaugeCircle className="h-4 w-4 text-primary" aria-hidden />
            Matrix occupancy
          </div>
          <span className="text-sm font-semibold text-foreground dark:text-white">
            {stats.matrixFillRate}% full
          </span>
        </div>
        <div className="flex items-center justify-between gap-3">
          <div className="flex items-center gap-2 text-sm text-muted-foreground">
            <Rocket className="h-4 w-4 text-primary" aria-hidden />
            Override-ready leaders
          </div>
          <span className="text-sm font-semibold text-foreground dark:text-white">
            {stats.leadershipReady} leaders · {stats.overrideCoverage}% coverage · {stats.reentryEligible} re-entries queued
          </span>
        </div>
      </dl>

      <div className="grid gap-3">
        {stats.timeline.map((step) => (
          <div
            key={step.label}
            className={cn(
              "flex items-start gap-3 rounded-2xl border border-border/60 p-3 text-sm dark:border-white/10",
              step.highlighted
                ? "bg-primary/10 text-foreground dark:bg-primary/20"
                : "bg-background/80 text-muted-foreground dark:bg-white/5"
            )}
          >
            <ArrowRight className="mt-1 h-4 w-4 text-primary" aria-hidden />
            <div>
              <p className="font-semibold">{step.value}</p>
              <p className="text-xs text-muted-foreground dark:text-white/70">{step.hint}</p>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}

type HybridPayoutDiagramProps = {
  payoutMix: HybridStats["payoutMix"];
  projectedPayout: number;
  binaryPayout: number;
  matrixPayout: number;
  unilevelPayout: number;
  formatter: Intl.NumberFormat;
};

function HybridPayoutDiagram({
  payoutMix,
  projectedPayout,
  binaryPayout,
  matrixPayout,
  unilevelPayout,
  formatter
}: HybridPayoutDiagramProps) {
  const segments = [
    {
      key: "binary" as const,
      label: "Binary",
      percent: payoutMix.binary,
      amount: binaryPayout,
      className: "bg-sky-500/80 dark:bg-sky-500/60",
      dotClass: "bg-sky-500"
    },
    {
      key: "matrix" as const,
      label: "Matrix",
      percent: payoutMix.matrix,
      amount: matrixPayout,
      className: "bg-emerald-500/80 dark:bg-emerald-500/60",
      dotClass: "bg-emerald-500"
    },
    {
      key: "unilevel" as const,
      label: "Unilevel",
      percent: payoutMix.unilevel,
      amount: unilevelPayout,
      className: "bg-purple-500/80 dark:bg-purple-500/60",
      dotClass: "bg-purple-500"
    }
  ];

  const totalPercent = segments.reduce((sum, segment) => sum + segment.percent, 0) || 1;

  return (
    <div className="space-y-4">
      <p className="text-xs font-medium uppercase tracking-wide text-muted-foreground">
        Hybrid payout distribution — total pool {formatter.format(projectedPayout)}
      </p>
      <div className="flex h-12 overflow-hidden rounded-full border border-border/60 bg-background/80 dark:border-white/10 dark:bg-white/5">
        {segments.map((segment) => {
          const width = (segment.percent / totalPercent) * 100;
          if (width <= 0) {
            return null;
          }

          return (
            <div
              key={segment.key}
              style={{ width: `${width}%` }}
              className={`${segment.className} h-full flex-none`}
              aria-label={`${segment.label} share ${segment.percent}%`}
            />
          );
        })}
      </div>
      <div className="grid gap-2 text-xs text-muted-foreground">
        {segments.map((segment) => (
          <div key={segment.key} className="flex items-center justify-between gap-3">
            <span className="flex items-center gap-2">
              <span className={`h-2.5 w-2.5 rounded-full ${segment.dotClass}`} aria-hidden />
              {segment.label} payouts
            </span>
            <span className="text-sm font-semibold text-foreground dark:text-white">
              {formatter.format(segment.amount)} ({segment.percent}%)
            </span>
          </div>
        ))}
      </div>
    </div>
  );
}
